"""
Inference script for AMF / NMF classification on stacked histopathology crop‑outs.

* Model : EfficientNet‑V2‑M
* Weights: /opt/ml/model/a_tarball_subdirectory/efficientnetv2_m_fold3_best.pth, please download it from https://midog2025.deepmicroscopy.org/files/efficientnetv2_m_fold3_best.pth and place it in the model/ folder
* Input  : /input/images/stacked-histopathology-roi-cropouts/*.tif(f) (multi‑page TIFF generated by Pillow)
* Output : /output/multiple-mitotic-figure-classification.json

Each TIFF page is scored independently.  The JSON contains one object per
page with the probability of atypical mitosis, regardless of the winning
class.

"""

from __future__ import annotations

from pathlib import Path
import json
from glob import glob
import numpy as np
from PIL import Image, ImageSequence
import torch
import torch.nn as nn
from torchvision import transforms
import os
from typing import Any, Dict, List
import logging as log
import uni2 as net

# Paths & constants

INPUT_PATH = Path("/input") if os.path.exists("/input") else Path("./input")
OUTPUT_PATH = Path("/output") if os.path.exists("/output") else Path("./output")
MODEL_WEIGHTS = Path("/opt/ml/model") if os.path.exists("/opt/ml/model") else Path("./opt/ml/model")

CLASS_NAMES = {1: "atypical", 0: "normal"}
THRESHOLD = 0.5  # probability threshold for classifying *normal*



# Helper functions

def get_interface_key() -> tuple[str, ...]:
    with open(INPUT_PATH / "inputs.json", "r") as f:
        inputs = json.load(f)
    return tuple(sorted(sv["interface"]["slug"] for sv in inputs))


def load_image_stack(dir_path: Path) -> List[np.ndarray]:
    tiffs = glob(str(dir_path / "*.tif")) + glob(str(dir_path / "*.tiff"))
    if not tiffs:
        raise FileNotFoundError(f"No TIFF files found in {dir_path}")
    with Image.open(tiffs[0]) as tif:
        return [np.array(p.convert("RGB")) for p in ImageSequence.Iterator(tif)]


def write_json(path: Path, obj):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as f:
        json.dump(obj, f, indent=4)


def _show_torch_cuda_info():
    print("=+=" * 10)
    avail = torch.cuda.is_available()
    print("Torch CUDA available:", avail)
    if avail:
        print("  num devices:", torch.cuda.device_count())
        cur = torch.cuda.current_device()
        print("  current device:", cur)
        print("  properties :", torch.cuda.get_device_properties(cur))
    print("=+=" * 10)

# Inference handler

def interf0_handler() -> int:
    # Load TIFF stack
    slices = load_image_stack(INPUT_PATH / "images/stacked-histopathology-roi-cropouts")

    # Prepare model
    _show_torch_cuda_info()
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model_paths = []
    for filename in os.listdir(MODEL_WEIGHTS):
        if filename.endswith(".safetensors"):
            model_paths.append(f'{MODEL_WEIGHTS}/{filename}')

    # Run inference
    outputs = []
    for model_path in model_paths:
        model = net.load(model_path)
        model.eval()
        model.to(device)
        logits = []
        with torch.no_grad():
            for sl in slices:
                x = torch.from_numpy(net.preprocess(sl)).to(device)
                logit = model(x)['logits'].mean(dim=0).cpu()
                logits.append(logit)
        outputs.append(torch.stack(logits))
    outputs = torch.stack(outputs).mean(dim=0).softmax(dim=-1).numpy()
    preds = []
    for output in outputs:
        cls_idx = np.argmax(output)
        p_atyp = output[1]
        preds.append({"class": CLASS_NAMES[cls_idx], "confidence": round(float(p_atyp), 4)})

    # Persist
    write_json(OUTPUT_PATH / "multiple-mitotic-figure-classification.json", preds)
    return 0

# Entrypoint

def run() -> int:
    handlers = {("stacked-histopathology-roi-cropouts",): interf0_handler}
    key = get_interface_key()
    if key not in handlers:
        raise KeyError(f"Unsupported interface combination: {key}")
    return handlers[key]()


if __name__ == "__main__":
    raise SystemExit(run())
